// Generated by dts-bundle v0.7.3

declare module 'zenith' {
    export * from 'zenith/common/conditions';
    export * from 'zenith/common/Logger';
    export * from 'zenith/common/string-builder';
    export * from 'zenith/common/timer';
    export * from 'zenith/comms/ajax';
    export * from 'zenith/data/identifiers';
    export * from 'zenith/data/list';
    export * from 'zenith/data/queue';
    export * from 'zenith/data/storage';
    export * from 'zenith/dom/element';
    export * from 'zenith/dom/events';
    export * from 'zenith/dom/shadow';
    export * from 'zenith/dom/styling';
}

declare module 'zenith/common/conditions' {
    /**
        * A collection of conditional checks, that provide boolean results for given input values.
        *
        * @export
        * @class Conditions
        */
    export class Conditions {
            /**
                * Checks whether the given value begins with the given character.
                *
                * @static
                * @param {string} value The value that the given character is matched against.
                * @param {string} char The character that should be matched with the end character of the given value.
                * @returns {boolean} Whether the given value begins with the given character.
                */
            static beginsWith(value: string, char: string): boolean;
            /**
                * Excutes a given callback. Voids the call if nothing was provided.
                *
                * @static
                * @param {Function} callback A function to be called.
                * @param {...any[]} args Any arguments to be passed in to the given callback.
                */
            static callOrVoid(callback: Function, ...args: any[]): void;
            /**
                * Checks whether the given value ends with the given character.
                *
                * @static
                * @param {string} value The value that the given character is matched against.
                * @param {string} char The character that should be matched with the end character of the given value.
                * @returns {boolean} Whether the given value ends with the given character.
                */
            static endsWith(value: string, char: string): boolean;
            /**
                * Providess an inline method of checking whether the value exists,
                * if not the given default will be used instead.
                *
                * @static
                * @template T The resulting value type.
                * @param {T} value The value to be checked.
                * @param {T} defaultValue The default value to used when the given value
                * is empty.
                * @returns {T} The resulting value.
                */
            static getValueOrDefault<T>(value: T, defaultValue: T): T;
            /**
                * Provides an inline method of preforming an "if" check whether a given
                * condition is true or false, a respective callback will be execute depending
                * on the result of the condition.
                *
                * @static
                * @template T The resulting value type.
                * @param {boolean} condition The given condition that dictates which callback to execute.
                * @param {() => T} trueCallback The given truthy callback.
                * @param {() => T} falseCallback The given falsy callback.
                * @returns {T} The resulting condition callback value.
                */
            static if<T>(condition: boolean, trueCallback: () => T, falseCallback: () => T): T;
            /**
                * Checks whether the given value is an array.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is an array.
                */
            static isArray(value: any): value is any[];
            /**
                * Checks whether the given array value has no elements.
                *
                * @static
                * @param {any[]} value The value to be checked.
                * @returns {boolean} Whether the given array value has no elements.
                */
            static isArrayEmpty(value: any[]): boolean;
            /**
                * Checks whether the given value is a boolean value.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is a boolean value.
                */
            static isBool(value: any): value is boolean;
            /**
                * Checks whether the given value is a date reference.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is a date reference.
                */
            static isDate(value: any): value is Date;
            /**
                * Checks whether the given value is a function.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is a function.
                */
            static isFunction(value: any): value is Function;
            /**
                * Determines whether the given value is an expected given
                * instance of a class.
                *
                * @static
                * @template T The expected class type.
                * @param {*} value The value to be checked.
                * @param {*} inst The class that the given value will be compared against.
                * @returns {value is T} Whether the given value is an instance of
                * the given expected class.
                */
            static isInstance<T>(value: any, inst: any): value is T;
            /**
                * Checks whether the given value is a node.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is a node.
                */
            static isNode(value: any): value is Node;
            /**
                * Checks whether the given value is a node list.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is a node list.
                */
            static isNodeList(value: any): value is NodeList;
            /**
                * Checks whether the given value is empty.
                *
                * @static
                * @param {(any[] | any)} value The value to be checked.
                * @returns {boolean} Whether the given value is empty.
                */
            static isNullOrEmpty(value: any | any[]): boolean;
            /**
                * Checks whether the given value is numeric.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is numeric.
                */
            static isNumber(value: any): value is number;
            /**
                * Checks whether the given value is a object.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is a object.
                */
            static isObject(value: any): value is object;
            /**
                * Checks whether the given value is of type string.
                *
                * @static
                * @param {any} value The value to be checked.
                * @returns {boolean} Whether the given value is of type string.
                */
            static isString(value: any): value is string;
            /**
                * Checks whether the given value is equal to the given type.
                *
                * @static
                * @param {*} value The value to be checked.
                * @param {string} type The type that the value is being checked for.
                * @returns {boolean} Whether the given value is equal to the given type.
                */
            static isType(value: any, type: string): boolean;
            /**
                * Checks whether the given value is undefined.
                *
                * @static
                * @param {*} value The value to be checked.
                * @returns {boolean} Whether the given value is undefined.
                */
            static isUndefined(value: any): value is undefined;
            /**
                * Checks whether the given object value contains the given property.
                *
                * @static
                * @param {object} value The object to be checked.
                * @param {string | number} prop The expected object property.
                * @returns {boolean} Whether the property is found in the given object value.
                */
            static objectContains(value: object, prop: string | number): boolean;
            /**
                * Checks whether the given objects are the same.
                *
                * @static
                * @param {*} value The first comparison object.
                * @param {*} comparison The second comparison object.
                * @returns {boolean} Whether the given objects are the same.
                */
            static objectsEqual(value: any, comparison: any): boolean;
    }
}

declare module 'zenith/common/Logger' {
    import '../common/extensions/object-extensions';
    import { LogLevel, Specifiers, LogTimerFunc } from 'zenith/common/logger-internals';
    export class Logger {
        level: LogLevel;
        static specifiers: typeof Specifiers;
        static error(message: string, ...options: any[]): void;
        static information(message: string, ...options: any[]): void;
        static stackTrace(message?: string, ...options: any[]): void;
        static timer(label: string): LogTimerFunc;
        static warning(message: string, ...options: any[]): void;
    }
}

declare module 'zenith/common/string-builder' {
    import '../common/extensions/string-extensions';
    /**
        * Represents a mutable string of characters.
        *
        * @export
        * @class StringBuilder
        */
    export class StringBuilder {
            /**
                * Gets the length of the current StringBuilder base string.
                *
                * @readonly
                */
            readonly length: number;
            /**
                * Creates an instance of a StringBuilder.
                * @param {string} [base]
                */
            constructor(base?: string);
            /**
                * Checks whether the given value is contained within the StringBuilder instance.
                *
                * @param {string | RegExp} value The value checked against the StringBuilder instance.
                * @returns {boolean} Whether or not the given value is contained in the StringBuilder instance.
                */
            contains(value: string | RegExp): boolean;
            /**
                * Append a given value to the start of the StringBuilder instance.
                *
                * @param {string} value The value to be added to the start.
                * @returns {this} The StringBuilder instance.
                */
            prepend(value: string): this;
            /**
                * Append a given value to the end of the StringBuilder instance.
                *
                * @param {string} value The value to added to the end.
                * @returns {this} The StringBuilder instance.
                */
            append(value: string): this;
            /**
                * Appends the break in text to the end of the StringBuilder instance.
                *
                * @param {string} value The value to be added to the start.
                * @returns {this} The StringBuilder instance.
                */
            appendBreak(): this;
            /**
                * Appends the default line terminator to the end of the StringBuilder instance.
                *
                * @param {string} value The value to be added to the start.
                * @returns {this} The StringBuilder instance.
                */
            appendLine(value: string): this;
            /**
                * Removes the specified range of characters from this instance.
                *
                * @param {string | RegExp} value The value to be removed.
                * @returns {this} The StringBuilder instance.
                */
            remove(value: string | RegExp): this;
            /**
                * Replaces all occurrences of a specified character or string in this instance with another specified character or string.
                *
                * @param {string} value The value to be replaced.
                * @param {string | RegExp} replacement The replacement value.
                * @returns {this} The StringBuilder instance.
                */
            replace(value: string | RegExp, replacement: string): this;
            /**
                * Removes all characters from the current StringBuilder instance.
                *
                * @returns {this} The StringBuilder instance.
                */
            clear(): this;
            /**
                * Converts the value of a StringBuilder to a String.
                *
                * @param {boolean} [trim=false] Whether or not to apply a trim to the result.
                * @returns {string} The resulting StringBuilder instance's string.
                */
            toString(trim?: boolean): string;
    }
}

declare module 'zenith/common/timer' {
    import { TimerOptions } from 'zenith/common/timer-internals';
    /**
        * Represents a time-based interval mechanism that executes a given elapse function everytime a given number of milliseconds has elapsed.
        *
        * @export
        * @class Timer
        */
    export class Timer {
            /**
                * Creates an instance of Timer.
                *
                * @param {() => void} onElapse A function that is executed upon reaching each interval cycle.
                * @param {number} [interval] The duration the Timer will wait until firing the onElapse callback. Number given in milliseconds.
                *  - Minimum interval is 50ms, if anything lower is given 50 is set by default.
                * @param {TimerOptions} [options] Optional properties that can be set to influence how the Timer functions.
                * - [autoStart = true] - Controls whether the Timer is started upon creation or suspended until start() has been called.
                * - [autoReset = true] - Controls whether the Timer excutes at an interval (true) or a delayed single execution (false).
                * - [repeatLimit = null] - Controls the number of cycles the Timer will execute until the Timer is stopped. This is ignored when autoReset is false. An empty value set the timer to execute for infinity.
                */
            constructor(onElapse: () => void, interval?: number, options?: TimerOptions);
            /**
                * Provides whether or not the Timer is currently running.
                *
                * @returns {boolean} Whether or not the Timer is running.
                */
            isRunning(): boolean;
            /**
                * Starts the Timers interval cycles.
                * This is ignored if the timer is already in a running state.
                *
                * @returns {this} The Timer instance.
                */
            start(): this;
            /**
                * Stops the Timer from running.
                * This is ignored if the timer is already in a suspended or stopped state.
                *
                * @returns {this} The Timer instance.
                */
            stop(): this;
    }
}

declare module 'zenith/comms/ajax' {
    import '../common/extensions/array-extensions';
    import '../common/extensions/object-extensions';
    import '../common/extensions/string-extensions';
    import { RequestOptions } from 'zenith/comms/ajax-internals';
    /**
        *
        *
        * @export
        * @class Ajax
        */
    export class Ajax {
            /**
                *
                *
                * @static
                * @param {string} baseUrl
                * @returns {string}
                */
            static cacheBust(baseUrl: string): string;
            /**
                *
                *
                * @static
                * @param {string} baseUrl
                * @param {({ [paramName: string]: string } | string)} params
                * @returns {string}
                */
            static params(baseUrl: string, params: {
                    [paramName: string]: string;
            } | URLSearchParams): string;
            /**
                *
                *
                * @static
                * @param {string} url
                * @param {RequestOptions} [options]
                */
            static sendRequest(url: string, options?: RequestOptions): void;
            /**
                *
                *
                * @static
                * @param {string} url
                * @param {RequestOptions} [options]
                */
            static sendRequestAsync(url: string, options?: RequestOptions): void;
    }
}

declare module 'zenith/data/identifiers' {
    export class Identifiers {
        static generateGuid(): string;
        static generateId(): string;
    }
}

declare module 'zenith/data/list' {
    import '../common/extensions/array-extensions';
    import { ArrayLoopCallback } from 'zenith/common/common-internals';
    /**
        * Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and manipulate lists.
        *
        * @export
        * @class List
        * @template T As the provided type.
        */
    export class List<T> {
            /**
                * Creates an instance of a List.
                *
                * @param {...T[]} items Rest parameter of all the items to be added to the List instance.
                */
            constructor(...items: T[]);
            /**
                * Returns the number of elements contained in the List.
                *
                * @readonly
                * @type {number}
                */
            readonly count: number;
            /**
                * Returns the first element of the List, if List is empty undefined is returned.
                *
                * @readonly
                * @type {T}
                */
            readonly first: T;
            /**
                * Returns the last element of the List, if List is empty undefined is returned.
                *
                * @readonly
                * @type {T}
                */
            readonly last: T;
            /**
                * Adds given value(s) to the end of the List.
                *
                * @param {T | T[]} value The value(s) to be added to the end of the List.
                * @returns {this} The List instance.
                */
            add(value: T | T[]): this;
            /**
                * Adds given value(s) to the start of the List.
                *
                * @param {T | T[]} value The value(s) to be added to the beginning of the List. Note: the first item will be the last item to added to the beginning of the List.
                * @returns {this} The List instance.
                */
            addToStart(value: T | T[]): this;
            /**
                * Determines whether all the elements of a List satisfy the specified test.
                *
                * @param {(item: T, index?: number, list?: T[]) => boolean} callback A function that tests each element of the List. Only if all elements are true then all will return true.
                * - item is the current element in the operation.
                * - index is the current index of the item.
                * - list is the current collection of items.
                * @returns {boolean} Whether or not all elements in the List met the callback's conditions.
                */
            all(callback: ArrayLoopCallback<T, boolean>): boolean;
            /**
                * Modify each element of the list in place with the given callback.
                *
                * @param {(item: T, index?: number, list?: T[]) => T} callback The modifiyng callback that gets applyed to each element in the List.
                * @returns {this} The List instance.
                */
            applyAll(callback: (item: T, index?: number, list?: T[]) => T): this;
            /**
                * Clears all elements from the List.
                *
                * @returns {this} The List instance.
                */
            clear(): this;
            /**
                * Adds all the elements of the List separated by the specified separator string.
                *
                * @param {string} [separator] A optional separator that is inserted between each List element. Default value is a whitespace.
                * @returns {string} The List's elements concatenated together with the given separator.
                */
            concatAll(separator?: string): string;
            /**
                * Determines whether a given value is contained in the List.
                *
                * @param {T} value Search value.
                * @param {number} [startIndex] The index to start searching from. Default is the start of the List.
                * @returns {boolean} Whether or not the List contains the given value.
                */
            contains(value: T, startIndex?: number): boolean;
            /**
                * Loop through all items in the List, passing the meta data of the given value to a given callback.
                * Note: This method does not cater for adding/removing items while looping.
                *
                * @param {(item: T, list?: T[], index?: number) => void} callback A function that is run over each item iteration of the List.
                * - item is the current element in the loop operation.
                * - list is the current collection of items.
                * - index is the current index of the item.
                * @returns {this} The List instance.
                */
            each(callback: ArrayLoopCallback<T, void>, exitCondition?: ArrayLoopCallback<T, boolean>): this;
            /**
                * Determines whether the given callback returns true for any element in the List.
                *
                * @param {(item: T, index?: number, list?: T[]) => boolean} predicate A function that returns true when any value meets the conditions of the callback.
                * - item is the current element in the operation.
                * - index is the current index of the item.
                * - list is the current collection of items.
                * @returns {boolean} Whether or not any element in he List met the callback's conditions.
                */
            exists(predicate: ArrayLoopCallback<T, boolean>): boolean;
            /**
                * Applies a predicate against the List and values that do not pass, get removed from the list.
                *
                * @param {(item: T, list?: T[], index?: number) => boolean} predicate TODO
                * - item is the current element in the loop operation.
                * - list is the current collection of items.
                * - index is the current index of the item.
                * @returns {this} The List instance.
                */
            filter(predicate: ArrayLoopCallback<T, boolean>): this;
            /**
                * TODO
                *
                * @param {(number)} index TODO
                * @returns {T} TODO
                */
            getValueByIndex(index: number): T;
            /**
                * Returns the index of the first occurrence of a given value in the List.
                *
                * @param {T} value
                * @param {number} [fromIndex=0]
                * @returns {number} Index of matched value or if nothing matchs null.
                */
            indexOf(value: T, fromIndex?: number): number;
            /**
                * Checks whether the List is empty or not.
                *
                * @returns {boolean} Whether the List is empty.
                */
            isEmpty(): boolean;
            /**
                * Returns the index of the last occurrence of a given value in the List.
                *
                * @param {T} value
                * @param {number} [fromIndex]
                * @returns {number} Index of matched value or if nothing matchs null.
                */
            lastIndexOf(value: T, fromIndex?: number): number;
            /**
                * Removes the given index/indices from the List.
                *
                * @param {(number | number[])} indices The index/indices to be removed from the List.
                * @returns {this} The List instance.
                */
            removeByIndex(indices: number | number[]): this;
            /**
                * Removes the given value(s) from the List.
                *
                * @param {(T | T[])} value The value(s) to be removed from the List.
                * @returns {this} The List instance.
                */
            removeByValue(value: T | T[]): this;
            /**
                * Removes the first element of the List.
                *
                * @returns {T} The value removed from the List.
                */
            removeFirst(): T;
            /**
                * Removes the last element of the List.
                *
                * @returns {T} The value removed from the List.
                */
            removeLast(): T;
            /**
                * Reverses the order of the List.
                *
                * @returns {this} The List instance.
                */
            reverse(): this;
            /**
                * Returns the value of the first element in the List that satisfies the given test callback.
                *
                * @param {(item: T, index?: number, list?: T[]) => boolean} predicate A function that returns true when a particular value is found.
                * - item is the current element in the finding operation.
                * - index is the current index of the item.
                * - list is the current collection of items.
                * @returns {T} Found value.
                */
            select(predicate: ArrayLoopCallback<T, boolean>): T;
            /**
                * Sorts the List according to the result from the given callback, if omitted it is sorted according to each character's Unicode point value.
                *
                * @param {(a: T, b: T) => number} [callback] Function that defines the sort order, where (a) and (b) are the elements being compared.
                * - If less than 0 sort (a) to lower index than (b), (a) comes first.
                * - If 0 leave (a) and (b) unchanged in respect to each other.
                * - If greater than 0 sort (b) to lower index than (a), (b) comes first.
                * - All undefined elements are sorted to the end of the array.
                * @returns {this} The List instance.
                */
            sort(callback?: (a: T, b: T) => number): this;
            /**
                * Converts the List to an array.
                *
                * @returns {T[]} A clone of the List's container array.
                */
            toArray(): T[];
            /**
                * TODO
                *
                * @param {(item: T, list?: T[], index?: number) => boolean} predicate TODO
                * - item is the current element in the loop operation.
                * - list is the current collection of items.
                * - index is the current index of the item.
                * @returns {T[]} Found values.
                */
            where(predicate: ArrayLoopCallback<T, boolean>): T[];
    }
}

declare module 'zenith/data/queue' {
    import { ArrayLoopCallback } from 'zenith/common/common-internals';
    /**
        * Represents a first-in, first-out collection of objects.
        *
        * @export
        * @class Queue
        * @template T As the provided type.
        */
    export class Queue<T> {
            /**
                * Creates an instance of a Queue.
                *
                * @param {...T[]} items
                */
            constructor(...items: T[]);
            /**
                * Returns the number of elements contained in the Queue.
                *
                * @readonly
                * @type {number}
                */
            readonly count: number;
            /**
                * Returns the previous item that was in the Queue, if no queue item was previously dequeued then undefined is returned.
                *
                * @readonly
                * @type {T}
                */
            readonly past: T;
            /**
                * Returns the next item in the Queue, if there is none then undefined is returned.
                *
                * @readonly
                * @type {T}
                */
            readonly peek: T;
            /**
                * Clears all elements from the Queue.
                *
                * @returns {this} The Queue instance.
                */
            clear(): this;
            /**
                * Determines whether a given value is contained in the Queue.
                *
                * @param {T} value Search value.
                * @returns {boolean} Whether or not the Queue contains the given value.
                */
            contains(value: T): boolean;
            /**
                * Removes first value in the Queue.
                *
                * @returns {T} The first value that is removed from the Queue.
                */
            dequeue(): T;
            /**
                * Loop through all enqueued items in the Queue, passing the meta data of the given value to a given callback.
                * Note: This method does not cater for en/de queuing items while looping.
                *
                * @param {(item: T, index?: number, list?: T[]) => void} callback A function that is run over each item iteration of the Queue.
                * - item is the current element in the loop operation.
                * - list is the current collection of items.
                * - index is the current index of the item.
                * @returns {this} This Queue Instance.
                */
            each(callback: ArrayLoopCallback<T, void>, exitCondition?: ArrayLoopCallback<T, boolean>): this;
            /**
                * Adds the given value(s) to the end of the Queue.
                *
                * @param {(T | T[])} value The value(s) to be added to the end of the Queue.
                * @returns {this} The Queue instance.
                */
            enqueue(value: T | T[]): this;
            /**
                * Reverses the order of the Queue.
                *
                * @returns {this} The Queue instance.
                */
            reverse(): this;
            /**
                * Sorts the Queue according to the result from the given callback, if omitted it is sorted according to each character's Unicode point value.
                *
                * @param {(a: T, b: T) => number} [callback] Function that defines the sort order, where (a) and (b) are the elements being compared.
                * - If less than 0 sort (a) to lower index than (b), (a) comes first.
                * - If 0 leave (a) and (b) unchanged in respect to each other.
                * - If greater than 0 sort (b) to lower index than (a), (b) comes first.
                * - All undefined elements are sorted to the end of the array.
                * @returns {this} The Queue instance.
                */
            sort(callback?: (a: T, b: T) => number): this;
            /**
                * Converts the Queue to an array.
                *
                * @returns {T[]} A clone of the Queue's container List array.
                */
            toArray(): T[];
    }
}

declare module 'zenith/data/storage' {
    import { BrowserStorage } from 'zenith/data/storage/browser-storage';
    import { Cookie } from 'zenith/data/storage/cookie';
    /**
        *
        *
        * @export
        * @class Storage
        */
    export class Storage {
            /**
                *
                *
                * @static
                */
            static Cookie: typeof Cookie;
            /**
                *
                *
                * @static
                */
            static Local: BrowserStorage;
            /**
                *
                *
                * @static
                */
            static Session: BrowserStorage;
    }
}

declare module 'zenith/dom/element' {
    import { DomElement } from 'zenith/dom/models/dom-element';
    export class Element {
        static create(tagName: string): DomElement;
        static fetch(selector: string): DomElement;
        static fetchAll(selector: string): NodeList;
    }
}

declare module 'zenith/dom/events' {
    export class Events {
        static load(callback: Function, parent?: Document | Window): void;
        static off(element: any, eventType: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        static on(element: any, eventType: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        static once(element: any, eventType: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        static ready(callback: Function, parent?: Document | Window): void;
    }
}

declare module 'zenith/dom/shadow' {
    /**
      *
      *
      * @export
      * @class Shadow
      */
    export class Shadow {
        static create(selector: any, options: any, element?: any): any;
        static onChange(element: any, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    }
}

declare module 'zenith/dom/styling' {
    import '../common/extensions/array-extensions';
    import '../common/extensions/object-extensions';
    import '../common/extensions/string-extensions';
    import { CssStyle, ReplacementClass } from 'zenith/dom/styling-internals';
    export class Styling {
        static addClass(element: HTMLElement, classNames: string | string[]): void;
        static css(element: HTMLElement, styles: CssStyle): void;
        static fadeIn(element: HTMLElement): void;
        static fadeOut(element: HTMLElement): void;
        static hasClass(element: HTMLElement, className: string): boolean;
        static hide(element: HTMLElement): void;
        static toggleClass(element: HTMLElement, classNames: string | string[]): void;
        static removeClass(element: HTMLElement, classNames: string | string[]): void;
        static replaceClass(element: HTMLElement, classNames: ReplacementClass | ReplacementClass[]): void;
        static show(element: HTMLElement): void;
    }
}

declare module 'zenith/common/logger-internals' {
    export type LogTimerFunc = {
        log: Function;
        end: Function;
    };
    export type LogCounterFunc = {
        count: Function;
        reset: Function;
    };
    export enum LogLevel {
        VERBOSE = 0,
        TRACE = 1,
        INFO = 2,
        WARN = 3,
        ERROR = 4,
        FATAL = 5,
        OFF = 6
    }
    export enum Specifiers {
        STRING = "%s",
        INTEGER = "%i",
        DIGIT = "%d",
        FPOINT = "%f",
        ELEMENT = "%o",
        OBJECT = "%O",
        CSS = "%c"
    }
    export enum DefaultLogMessages {
        Deprecated = "This method has been deprecated.",
        NotYetImplemented = "This functionality has not yet been implemented."
    }
    export interface OriginPath {
        delimiter?: string;
        path: string[];
    }
}

declare module 'zenith/common/timer-internals' {
    export interface TimerOptions {
        autoStart?: boolean;
        autoReset?: boolean;
        repeatLimit?: number;
    }
    export interface TimerType {
        start: string;
        stop: string;
    }
}

declare module 'zenith/comms/ajax-internals' {
    /**
        *
        *
        * @export
        * @interface RequestEventHandlers
        */
    export interface RequestEventHandlers {
            /**
                *
                */
            state?: {
                    [stateNumber: string]: (xhr: XMLHttpRequest) => void;
            };
            /**
                *
                */
            status?: {
                    [statusNumber: string]: (xhr: XMLHttpRequest) => void;
            };
            /**
                * The abort event is fired when the loading of a resource has been aborted.
                */
            abort?: (xhr: XMLHttpRequest) => void;
            /**
                * This event is fired after send off the Ajax request.
                */
            afterSend?: (xhr: XMLHttpRequest) => void;
            /**
                * This event is fired before send off the Ajax request.
                */
            beforeSend?: (xhr: XMLHttpRequest) => void;
            /**
                * The complete event is fired when the request has reached the end, regardless of whether the request was successful or failed.
                */
            complete?: (xhr: XMLHttpRequest) => void;
            /**
                * The error event is fired when an error has occured while making a request or during the request.
                */
            error?: (message: string, errorType?: string, xhr?: XMLHttpRequest) => void;
            /**
                * The progress event is fired to indicate that an operation is in progress.
                */
            progress?: (xhr: XMLHttpRequest) => void;
            /**
                * The loadstart event is fired when progress has begun on the loading of a resource.
                */
            loadStart?: (xhr: XMLHttpRequest) => void;
            /**
                * The load event is fired when a resource and its dependent resources have finished loading.
                */
            load?: (xhr: XMLHttpRequest) => void;
            /**
                * The loadend event is fired when progress has stopped on the loading of a resource (e.g. after "error", "abort", or "load" have been dispatched).
                */
            loadEnd?: (xhr: XMLHttpRequest) => void;
            /**
                * The success event is fired when the request has been successful.
                */
            success?: (data: any, xhr?: XMLHttpRequest) => void;
            /**
                * The timeout event is fired when Progression is terminated due to preset time expiring.
                */
            timeout?: {
                    time: number;
                    callback: (event: any) => void;
            };
    }
    /**
        *
        *
        * @export
        * @interface RequestOptions
        */
    export interface RequestOptions {
            /**
                *
                */
            params?: {
                    [paramName: string]: string;
            } | URLSearchParams;
            /**
                *
                */
            method?: string;
            /**
                *
                */
            sendData?: any;
            /**
                *
                */
            contentType?: string;
            /**
                *
                */
            mimeType?: string;
            /**
                *
                */
            responseType?: string;
            /**
                *
                */
            headers?: {
                    [header: string]: string;
            };
            /**
                *
                */
            async?: boolean;
            /**
                *
                */
            cache?: boolean;
            /**
                *
                */
            username?: string;
            /**
                *
                */
            password?: string;
            /**
                *
                */
            handlers?: RequestEventHandlers;
    }
}

declare module 'zenith/common/common-internals' {
    import { Dictionary } from 'zenith/data/dictionary';
    export type DictionaryLoopCallback<TKey, TValue> = (value: TValue, key?: TKey, dictionary?: Dictionary<TKey, TValue>) => void;
    export type ArrayLoopCallback<T, R> = (item: T, index?: number, array?: T[]) => R;
    export type ObjectLoopCallback<T> = (value: T, key?: string, index?: number) => void;
    export type KeyValuePair<TValue> = {
        [key: string]: TValue;
    };
}

declare module 'zenith/data/storage/browser-storage' {
    import { KeyValuePair } from 'zenith/common/common-internals';
    import '../../common/extensions/array-extensions';
    import '../../common/extensions/object-extensions';
    import '../../common/extensions/string-extensions';
    /**
        *
        *
        * @export
        * @class BrowserStorage
        */
    export class BrowserStorage {
            /**
                * Creates an instance of BrowserStorage.
                *
                * @param {Storage} context
                */
            constructor(context: Storage);
            /**
                *
                *
                * @returns {number}
                */
            count(): number;
            /**
                *
                *
                */
            clear(): void;
            /**
                *
                *
                * @param {string} key
                * @param {*} value
                */
            add(key: string, value: string): void;
            /**
                *
                *
                * @param {{ [key: string]: string }} keyAndValue
                */
            addMultiple(keyAndValue: KeyValuePair<string>): void;
            /**
                *
                *
                * @param {(string | string[])} key
                */
            remove(key: string | string[]): void;
            /**
                *
                *
                * @param {string} key
                * @returns {string}
                */
            fetch(key: string): string;
    }
}

declare module 'zenith/data/storage/cookie' {
    import '../../common/extensions/array-extensions';
    import { CookieMetadata, RetrievedCookieNameValuePair } from 'zenith/data/storage/cookie-internals';
    /**
        *
        *
        * @export
        * @class Cookie
        */
    export class Cookie {
            /**
                *
                *
                * @static
                * @returns {number}
                */
            static count(): number;
            /**
                *
                *
                * @static
                */
            static clear(): void;
            /**
                *
                *
                * @static
                * @param {string} name
                * @param {string} value
                * @param {(Date | number | string)} [expiry]
                * @param {string} [path]
                */
            static add(name: string, value: string, expiry?: Date | number | string, path?: string): void;
            /**
                *
                *
                * @static
                * @param {CookieMetadata[]} cookieCollection
                */
            static addMultiple(cookieCollection: CookieMetadata[]): void;
            /**
                *
                *
                * @static
                * @param {(string | string[])} name
                */
            static remove(name: string | string[]): void;
            /**
                *
                *
                * @static
                * @param {string} name
                * @returns {RetrievedCookieNameValuePair}
                */
            static fetch(name: string): RetrievedCookieNameValuePair;
            /**
                *
                *
                * @static
                */
            static check(): void;
    }
}

declare module 'zenith/dom/models/dom-element' {
    import { ReplacementClass } from 'zenith/dom/styling-internals';
    /**
        *
        *
        * @export
        * @class DomElement
        */
    export class DomElement {
            /**
                *
                *
                * @type {HTMLElement}
                */
            element: HTMLElement;
            /**
                *
                *
                * @type {string}
                */
            selector: string;
            /**
                * Creates an instance of a DomElement.
                *
                * @param {string} selector
                */
            constructor(selector: string);
            /**
                *
                *
                * @type {string}
                */
            id: string;
            setId(identifier: string): this;
            /**
                *
                *
                * @type {string}
                */
            inner: string;
            setInner(content: string): this;
            /**
                *
                *
                * @type {string}
                */
            text: string;
            setText(content: string): this;
            /**
                *
                *
                * @param {(string | string[])} className
                * @returns {this}
                */
            addClass(className: string | string[]): this;
            /**
                *
                *
                * @param {Node} content
                * @returns {this}
                */
            append(content: Node): this;
            /**
                *
                *
                * @param {{ [ styleName: string ]: string }} styles
                * @returns {this}
                */
            css(styles: {
                    [styleName: string]: string;
            }): this;
            /**
                *
                *
                * @param {boolean} [value=null]
                * @returns {this}
                */
            disable(value?: boolean): this;
            /**
                *
                *
                * @returns {this}
                */
            fadeIn(): this;
            /**
                *
                *
                * @returns {this}
                */
            fadeOut(): this;
            /**
                *
                *
                * @param {string} name
                * @returns {string}
                */
            getAttribute(name: string): string;
            /**
                *
                *
                * @param {string} classNames
                * @returns {boolean}
                */
            hasClass(classNames: string): boolean;
            /**
                *
                *
                * @returns {this}
                */
            hide(): this;
            /**
                *
                *
                * @param {string} eventType
                * @param {EventListenerOrEventListenerObject} handler
                * @param {(boolean | AddEventListenerOptions)} [options]
                * @returns {this}
                */
            off(eventType: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): this;
            /**
                *
                *
                * @param {string} eventType
                * @param {EventListenerOrEventListenerObject} handler
                * @param {(boolean | AddEventListenerOptions)} [options]
                * @returns {this}
                */
            on(eventType: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): this;
            /**
                *
                *
                * @param {string} eventType
                * @param {EventListenerOrEventListenerObject} handler
                * @param {(boolean | AddEventListenerOptions)} [options]
                * @returns {this}
                */
            once(eventType: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): this;
            /**
                *
                *
                * @param {string} selector
                * @returns {this}
                */
            only(selector: string): this;
            /**
                *
                *
                * @param {Node} content
                * @param {Node} [beforeElement]
                * @returns {this}
                */
            prepend(content: Node, beforeElement?: Node): this;
            /**
                *
                *
                * @param {string} name
                * @returns {this}
                */
            removeAttribute(name: string): this;
            /**
                *
                *
                * @param {(string | string[])} classNames
                * @returns {this}
                */
            toggleClass(classNames: string | string[]): this;
            /**
                *
                *
                * @param {(string | string[])} classNames
                * @returns {this}
                */
            removeClass(classNames: string | string[]): this;
            /**
                *
                *
                * @param {(ReplacementClass | ReplacementClass[])} classNames
                * @returns {this}
                */
            replaceClass(classNames: ReplacementClass | ReplacementClass[]): this;
            /**
                *
                *
                * @param {string} name
                * @param {string} value
                * @returns {this}
                */
            setAttribute(name: string, value: string): this;
            /**
                *
                *
                * @returns {this}
                */
            show(): this;
            /**
                *
                *
                * @returns {string}
                */
            toString(): string;
    }
}

declare module 'zenith/dom/styling-internals' {
    import { KeyValuePair } from 'zenith/common/common-internals';
    export interface ReplacementClass {
        newClass: string;
        oldClass: string;
    }
    export type CssStyle = KeyValuePair<string>;
}

declare module 'zenith/data/dictionary' {
    import '../common/extensions/array-extensions';
    import { DictionaryLoopCallback } from 'zenith/common/common-internals';
    /**
        *
        *
        * @export
        * @class Dictionary
        * @template TKey
        * @template TValue
        */
    export class Dictionary<TKey, TValue> {
            /**
                *
                *
                * @readonly
                * @type {[ TKey, TValue ][]}
                */
            readonly entries: [TKey, TValue][];
            /**
                *
                *
                * @readonly
                * @type {TKey[]}
                */
            readonly keys: TKey[];
            /**
                *
                *
                * @readonly
                * @type {TValue[]}
                */
            readonly values: TValue[];
            /**
                *
                *
                * @readonly
                * @type {number}
                */
            readonly count: number;
            /**
                * Creates an instance of Dictionary.
                * @param {...[ TKey, TValue ][]} items
                */
            constructor(...items: [TKey, TValue][]);
            /**
                *
                *
                * @param {TKey[]} keys
                * @returns {TValue[]}
                */
            fetchMany(keys: TKey[]): TValue[];
            /**
                *
                *
                * @param {TKey} key
                * @returns {TValue}
                */
            fetch(key: TKey): TValue;
            /**
                *
                *
                * @param {TKey} key
                * @param {TValue} value
                * @returns {this}
                */
            add(key: TKey, value: TValue): this;
            /**
                *
                *
                * @param {TKey} key
                * @returns {this}
                */
            remove(key: TKey): this;
            /**
                *
                *
                * @param {DictionaryLoopCallback<TKey, TValue>} callback
                * @returns {this}
                */
            each(callback: DictionaryLoopCallback<TKey, TValue>): this;
            /**
                *
                *
                * @returns {boolean}
                */
            isEmpty(): boolean;
            /**
                *
                *
                * @returns {this}
                */
            clear(): this;
            /**
                *
                *
                * @param {TKey} key
                * @returns {boolean}
                */
            contains(key: TKey): boolean;
    }
}

declare module 'zenith/data/storage/cookie-internals' {
    export interface CookieMetadata {
        name: string;
        value: string;
        expiry?: Date | number | string;
        path?: string;
    }
    export interface RetrievedCookieNameValuePair {
        name: string;
        value: string;
        raw: string;
    }
}

